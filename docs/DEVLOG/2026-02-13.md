# Project PFE – Day 4 Implementation Log

**Date:** 2026-02-13  
**Goal (Day 4):** Implement asynchronous AI processing pipeline with queue system, audit trail, and idempotence guarantees.

---

## Deliverables (created/updated)

- `database/migrations/XXXX_create_ai_requests_table.php`
- `database/migrations/XXXX_create_extractions_table.php`
- `database/migrations/XXXX_create_jobs_table.php`
- `database/migrations/XXXX_create_failed_jobs_table.php`
- `app/Models/AiRequest.php`
- `app/Models/Extraction.php`
- `app/Models/Document.php` (updated)
- `app/Services/AIService.php`
- `app/Jobs/ProcessDocumentJob.php`
- `app/Services/DocumentService.php` (updated)
- `.env` (QUEUE_CONNECTION=database)

---

## 1) Database Extensions

### ai_requests table

**Purpose:** Audit trail for every AI processing attempt

| Field               | Type          | Description                           |
|---------------------|---------------|---------------------------------------|
| id                  | bigIncrements | Primary key                           |
| request_id          | uuid (unique) | Unique identifier for each AI call    |
| document_id         | foreignId     | Links to documents table              |
| doc_type_sent       | string (null) | Document type sent to AI              |
| http_status         | integer (null)| HTTP status code from AI service      |
| status              | string        | SUCCESS or FAILED                     |
| processing_time_ms  | integer (null)| Processing duration in milliseconds   |
| error_message       | text (null)   | Error details if processing failed    |
| timestamps          | -             | created_at, updated_at                |

### Migration executed
```bash
php artisan migrate
```

### Key decisions
- `request_id` as UUID for distributed tracing
- `status` tracks success/failure for analytics
- `processing_time_ms` for performance monitoring
- `error_message` captures exception details

---

### extractions table

**Purpose:** Store AI extraction results with version control

| Field          | Type          | Description                              |
|----------------|---------------|------------------------------------------|
| id             | bigIncrements | Primary key                              |
| document_id    | foreignId     | Links to documents table                 |
| ai_request_id  | foreignId     | Links to ai_requests table               |
| version        | integer       | Extraction version (starts at 1)         |
| result_json    | json          | Complete AI response (API contract v1)   |
| timestamps     | -             | created_at, updated_at                   |

**Unique constraint:** `(document_id, version)`

### Key decisions
- Unique constraint enforces one extraction per version per document
- `ai_request_id` creates proper audit chain: `documents → ai_requests → extractions`
- `result_json` stores complete API contract v1 response
- Version control enables future re-processing

---

### Queue infrastructure tables

**Tables created:**
- `jobs` - Pending queue jobs
- `failed_jobs` - Failed jobs for debugging (created auto in laravel)

**Configuration:**
```
QUEUE_CONNECTION=database
```

---

## 2) Models and Relationships

### AiRequest Model

**File:** `app/Models/AiRequest.php`

Configured with:
- Fillable: `request_id`, `document_id`, `doc_type_sent`, `http_status`, `status`, `processing_time_ms`, `error_message`
- Relationship: `belongsTo(Document::class)`, `hasOne(Extraction::class)`

---

### Extraction Model

**File:** `app/Models/Extraction.php`

Configured with:
- Fillable: `document_id`, `ai_request_id`, `version`, `result_json`
- Casts: `result_json → array`
- Relationships: `belongsTo(Document::class)`, `belongsTo(AiRequest::class)`

---

### Document Model (Updated)

**New relationships added:**
- `hasMany(AiRequest::class)`
- `hasMany(Extraction::class)`

---

## 3) AI Service (Mock Implementation)

**File:** `app/Services/AIService.php`

### Purpose
Mock AI service returning contract v1 compliant data

### Implementation
Returns `meta`, `fields`, `confidence`, `warnings`, `errors` matching frozen API contract from Day 2

### Contract v1 compliance
Ready to be replaced with real FastAPI integration

---

## 4) ProcessDocumentJob

**File:** `app/Jobs/ProcessDocumentJob.php`

### Configuration
- Implements: `ShouldQueue`, `ShouldBeUnique`
- Retries: 3 attempts with 10s backoff
- Uniqueness: 60 seconds per document ID

### Concurrency protection
`ShouldBeUnique` prevents duplicate job execution using document ID as key

---

### handle() Method Logic

**Step 1: Idempotence Guards**
- Skip if status already `PROCESSED`
- Skip if extraction v1 exists

**Step 2: Update Status to PROCESSING**
```php
$document->update(['status' => DocumentStatus::PROCESSING]);
```

**Step 3: AI Processing**
Call `AIService::process()` with document file path

**Step 4: Atomic Database Updates**
```
DB::transaction:
  → create AiRequest (SUCCESS)
  → create Extraction (v1)
  → status = PROCESSED
```

### Architecture decisions
- Status updated to `PROCESSING` immediately before AI call (committed separately)
- AI call happens outside transaction to avoid locking DB during processing
- Result writes wrapped in single transaction for atomicity
- AiRequest created before Extraction (correct FK relationship)
- Status updated to `PROCESSED` at the end

### Production consideration
This approach ensures accurate status tracking - document shows `PROCESSING` while AI is actually running, not after completion. Critical for real-time monitoring in production environments.

---

### failed() Method

**Purpose:** Handle job failures after all retries exhausted

**Actions:**
- Update document status to `FAILED`
- Create AiRequest with `status = FAILED`
- Capture exception message for debugging

### Benefits
Complete audit trail even for failures

---

## 5) DocumentService Integration

**File:** `app/Services/DocumentService.php`

### Update
Wrapped document creation in transaction and added job dispatch:
```php
ProcessDocumentJob::dispatch($document->id)->afterCommit();
```

### Key mechanism
`afterCommit()` ensures job dispatched only after database commit, preventing race conditions

---

## 6) Workflow Status Lifecycle

**Complete workflow implemented:**
```
UPLOADED (upload complete)
    ↓
Queue (job dispatched)
    ↓
PROCESSING (job started, status updated immediately)
    ↓
AI Service (mock processing - happens while status is PROCESSING)
    ↓
PROCESSED (success) or FAILED (error after retries)
```

**Future extension:**
```
PROCESSED
    ↓
VALIDATED (Day 5+ - Human-in-the-Loop)
```

---

## 7) Testing Results (Postman)

### Test 1: Normal Flow

**Action:** Upload new document

**Postman Response (201):**
```json
{
    "id": 2,
    "status": "UPLOADED",
    "original_filename": "facture2.jpg",
    "mime_type": "image/jpeg",
    "file_size": 66181,
    "created_at": "2026-02-13T16:53:50.000000Z"
}
```

**Queue Worker Output:**
```
2026-02-13 16:53:54 App\Jobs\ProcessDocumentJob RUNNING
2026-02-13 16:53:54 App\Jobs\ProcessDocumentJob 308.50ms DONE
```

**Database Verification:**
- documents: id=2, status=PROCESSED
- ai_requests: document_id=2, status=SUCCESS
- extractions: document_id=2, version=1

**Result:** Success - Full pipeline working

---

### Test 2: Idempotence

**Action:** Manually dispatch job for same document
```bash
php artisan tinker
App\Jobs\ProcessDocumentJob::dispatch(2);
```

**Queue Worker Output:**
```
2026-02-13 17:00:16 App\Jobs\ProcessDocumentJob RUNNING
2026-02-13 17:00:16 App\Jobs\ProcessDocumentJob 56.46ms DONE
```

**Performance:** 56ms (idempotence guard triggered)

**Database Verification:**
- extractions: Still only 1 record for document_id=2

**Result:** Success - Idempotence working correctly

---

## 8) Architecture Validation

### Day 2 Design Compliance
- Laravel owns workflow and persistence
- Async processing via queue system
- Status-driven workflow
- Complete audit trail
- Idempotence at both application and database level

### SOLID Principles
- Single Responsibility: Each component has clear purpose
- Dependency Injection: Job receives AIService via container
- Open/Closed: Easy to extend with real FastAPI integration

### Laravel Best Practices
- Database transactions for atomic updates
- Queue jobs for async processing
- Eloquent relationships properly defined
- Failed job handling implemented
- Retry logic with exponential backoff
- Status updates committed before long-running operations

---

## 9) System State at End of Day 4

### Current capabilities
- Asynchronous document processing
- Complete audit trail (ai_requests table)
- Extraction result storage (extractions table)
- Retry mechanism with exponential backoff
- Idempotence protection (prevents duplicate processing)
- Concurrency safety (unique job constraint)
- Failure handling with proper status tracking
- Queue worker infrastructure
- Accurate real-time status tracking during processing

### Current workflow
```
UPLOADED (implemented Day 3)
    ↓
Queue dispatch (implemented Day 4)
    ↓
PROCESSING (implemented Day 4 - updated immediately)
    ↓
AI processing (mock - Day 4 - runs while status shows PROCESSING)
    ↓
PROCESSED / FAILED (implemented Day 4)
    ↓
VALIDATED (planned Day 5+)
```

---

## Out of scope (intentional for Day 4)

- Real FastAPI integration (using mock for now)
- OCR implementation (mock returns hardcoded data)
- Document type classification (hardcoded in mock)
- Human-in-the-Loop validation interface
- Real-time status updates via WebSockets
- Advanced queue monitoring/dashboard