# Project PFE – Day 4 Implementation Log

**Date:** 2026-02-13  
**Goal (Day 4):** Implement an asynchronous document processing pipeline (queue-based) with an audit trail and idempotence protections, while keeping the AI part mocked (FastAPI integration later).

---

## Deliverables (created/updated)

> Note: queue tables are only listed if generated via `php artisan queue:table` / `php artisan queue:failed-table`.

- `backend/database/migrations/XXXX_create_ai_requests_table.php`
- `backend/database/migrations/XXXX_create_extractions_table.php`
- `backend/database/migrations/XXXX_create_jobs_table.php` *(if generated)*
- `backend/database/migrations/XXXX_create_failed_jobs_table.php` *(if generated)*
- `backend/app/Models/AiRequest.php`
- `backend/app/Models/Extraction.php`
- `backend/app/Models/Document.php` *(updated: relationships)*
- `backend/app/Services/AIService.php` *(mock)*
- `backend/app/Jobs/ProcessDocumentJob.php`
- `backend/app/Services/DocumentService.php` *(updated: dispatch job after commit)*
- `backend/.env` *(updated: `QUEUE_CONNECTION=database`)*

---

## 1) Database Extensions

### 1.1 `ai_requests` table

**Purpose:** Maintain a complete audit trail for every AI processing attempt (success or failure).

| Field | Type | Description |
|---|---|---|
| id | bigIncrements | Primary key |
| request_id | uuid (unique) | Unique identifier per AI call |
| document_id | foreignId | Link to `documents` |
| doc_type_sent | string (nullable) | Document type hint sent to AI |
| http_status | integer (nullable) | HTTP status returned by AI service |
| status | string | `SUCCESS` or `FAILED` |
| processing_time_ms | integer (nullable) | Processing duration (ms) |
| error_message | text (nullable) | Error details |
| timestamps | - | created_at / updated_at |

**Key decisions**
- `request_id` is UUID → supports distributed tracing later.
- `status` + `processing_time_ms` → useful for analytics and monitoring.
- `error_message` preserved → better debugging and reporting.

---

### 1.2 `extractions` table

**Purpose:** Store AI extraction results (full response JSON), with versioning for future re-processing.

| Field | Type | Description |
|---|---|---|
| id | bigIncrements | Primary key |
| document_id | foreignId | Link to `documents` |
| ai_request_id | foreignId | Link to `ai_requests` |
| version | integer | Extraction version (starts at 1) |
| result_json | json | Full AI response (API contract v1) |
| timestamps | - | created_at / updated_at |

**Constraint:** unique `(document_id, version)`

**Key decisions**
- FK chain enforced: `documents → ai_requests → extractions` (auditability).
- `result_json` stores the complete contract v1 payload (traceability).
- Versioning enables future “re-run extraction” safely.

---

### 1.3 Queue infrastructure tables (database queue)

**Configuration**
```env
QUEUE_CONNECTION=database
```

If using database queue, migrations should exist for:
- `jobs`
- `failed_jobs`

---

## 2) Models & Relationships

### 2.1 `AiRequest` model
- Fillable includes: `request_id`, `document_id`, `doc_type_sent`, `http_status`, `status`, `processing_time_ms`, `error_message`
- Relationships:
  - `belongsTo(Document::class)`
  - `hasOne(Extraction::class)`

### 2.2 `Extraction` model
- Fillable includes: `document_id`, `ai_request_id`, `version`, `result_json`
- Casts:
  - `result_json` → array
- Relationships:
  - `belongsTo(Document::class)`
  - `belongsTo(AiRequest::class)`

### 2.3 `Document` model (updated)
- New relationships:
  - `hasMany(AiRequest::class)`
  - `hasMany(Extraction::class)`

---

## 3) AI Service (Mock)

**File:** `backend/app/Services/AIService.php`

**Purpose**
- Provide a stable contract-v1 compliant response without integrating FastAPI yet.

**Behavior**
- Returns a payload matching the frozen API Contract (Day 2): `meta`, `fields`, `confidence`, `warnings`, `errors`.
- Designed to be replaced by a real HTTP call to FastAPI later.

---

## 4) Async Processing Job

**File:** `backend/app/Jobs/ProcessDocumentJob.php`

### 4.1 Configuration
- Implements: `ShouldQueue`, `ShouldBeUnique`
- Retries: 3 attempts, 10s backoff
- Uniqueness window: 60s per document

**Important note**
- `ShouldBeUnique` protects against *concurrent duplicates*.
- True idempotence is enforced via *guards* (see below), even after the uniqueness window.

---

### 4.2 `handle()` logic (high-level)

**Step 1 — Idempotence guards**
- Skip if document status is already `PROCESSED`
- Skip if extraction version 1 already exists

**Step 2 — Status update**
- Update to `PROCESSING` immediately (separate commit), so the system reflects the real runtime state.

**Step 3 — AI call**
- Call `AIService::process()` (mock) using the stored file path.

**Step 4 — Atomic persistence**
- Write results inside a single `DB::transaction()`:
  - Create `AiRequest` (SUCCESS)
  - Create `Extraction` (version 1)
  - Update document status → `PROCESSED`

**Design decisions**
- AI call happens outside the transaction to avoid DB locks during long processing.
- Result persistence is atomic to avoid partial writes.

---

### 4.3 `failed()` method (after retries exhausted)

**Purpose:** Ensure failures are recorded and traceable.

**Actions**
- Update document status → `FAILED`
- Create `AiRequest` with `status=FAILED`
- Store exception message into `error_message`

**Benefit:** audit trail exists even when processing fails.

---

## 5) DocumentService Integration

**File:** `backend/app/Services/DocumentService.php`

**Update**
- Dispatch job after the upload is committed:
```php
ProcessDocumentJob::dispatch($document->id)->afterCommit();
```

**Why `afterCommit()`**
- Prevents race conditions where a job starts before the document row is fully committed.

---

## 6) Workflow Status Lifecycle (implemented)

```
UPLOADED (upload done)
  ↓
Queue dispatch (job created)
  ↓
PROCESSING (job started)
  ↓
PROCESSED (success) or FAILED (error after retries)
```

Future:
```
PROCESSED → VALIDATED (HITL, Day 5+)
```

---

## 7) Testing Results (Postman + Worker)

### Test 1 — Normal flow
- Upload returns `201` with status `UPLOADED`
- Worker runs the job and completes
- DB checks:
  - `documents.status = PROCESSED`
  - `ai_requests` row created with `SUCCESS`
  - `extractions` row created with `version = 1`

### Test 2 — Idempotence
- Manual dispatch of job for the same document
- Job finishes quickly (guards triggered)
- DB checks:
  - No duplicate extraction created (still one v1 record)

---

## 8) Architecture Validation

### Compliance with Day 2 design
- Laravel owns persistence + workflow states.
- Asynchronous processing implemented via queue.
- Audit trail implemented (`ai_requests`).
- Full AI outputs stored (`extractions.result_json`).
- Idempotence protections implemented at application level and reinforced by DB uniqueness constraints.

### Laravel best practices applied
- Queue jobs for async work
- `afterCommit()` dispatch
- Transactions for atomic writes
- Relationships & casts defined cleanly
- Failure path handled explicitly

---

## 9) System State (End of Day 4)

### Current capabilities
- Upload → async processing
- Status lifecycle: `UPLOADED → PROCESSING → PROCESSED/FAILED`
- Audit trail of every attempt
- Storage of full extraction results (JSON)
- Retry + failure handling
- Idempotence protections + concurrency safety

---

## Out of scope (intentional for Day 4)
- Real FastAPI HTTP integration (mock used)
- OCR implementation (still mocked)
- Document type classification logic
- HITL UI (frontend validation)
- WebSockets real-time updates
- Advanced queue monitoring dashboard