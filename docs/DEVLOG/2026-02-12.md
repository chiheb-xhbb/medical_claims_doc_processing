# Project PFE – Day 3 Implementation Log

**Date:** 2026-02-12  
**Goal (Day 3):** Implement backend upload pipeline with clean architecture, secure file storage, and stable workflow foundation.

---

## Deliverables 

- `database/migrations/2026_02_12_143802_create_documents_table.php`
- `app/Enums/DocumentStatus.php`
- `app/Models/Document.php`
- `app/Http/Requests/StoreDocumentRequest.php`
- `app/Services/DocumentService.php`
- `app/Http/Controllers/Api/DocumentController.php`
- `routes/api.php` 

---

## 1) Database Implementation

**Migration:** `create_documents_table`

### Schema
Created table with the following structure:

| Field             | Type                  | Description                              |
|-------------------|-----------------------|------------------------------------------|
| id                | bigIncrements         | Primary key (Laravel default)            |
| user_id           | foreignId (nullable)  | Future auth integration                  |
| original_filename | string                | Client-provided filename                 |
| file_path         | string                | Storage path (internal use only)         |
| mime_type         | string                | File MIME type                           |
| file_size         | unsignedBigInteger    | File size in bytes                       |
| doc_type          | string (nullable)     | Document category (pharmacy/lab/unknown) |
| status            | string (indexed)      | Workflow state                           |
| error_message     | text (nullable)       | Error details if processing fails        |
| timestamps        | -                     | created_at, updated_at                   |

### Migration executed
```bash
php artisan migrate
```

### Key decisions
- Standard Laravel `$table->id()` primary key used
- `status` indexed for frequent queries
- `file_path` stored as internal path only (not exposed in API responses for security)
- `user_id` nullable (auth deferred to later)
- Default disk: `local` → `storage/app/`

---

## 2) Domain Layer

### DocumentStatus Enum

**File:** `app/Enums/DocumentStatus.php`

Implemented strict workflow states:
- `UPLOADED` → fichier reçu/validé/stocké
- `PROCESSING` → traitement IA en cours
- `PROCESSED` → résultat IA enregistré
- `VALIDATED` → validation humaine terminée
- `FAILED` → échec du traitement IA

Benefits:
- Type safety
- Prevents invalid status values
- IDE autocomplete support
- Workflow consistency enforced at code level

---

### Document Model

**File:** `app/Models/Document.php`

Configured with:
- Fillable attributes: `original_filename`, `file_path`, `mime_type`, `file_size`, `doc_type`, `status`, `error_message`, `user_id`
- Casts: `status → DocumentStatus::class`, `file_size → integer`
- Relationship: `belongsTo(User::class)` (ready for future auth)

---

## 3) Validation Layer

**File:** `app/Http/Requests/StoreDocumentRequest.php`

### Validation rules
- `required`
- `file`
- `mimes:pdf,jpg,jpeg,png`
- `max:10240` (10MB)

### Custom error messages
Clear user-facing messages for each validation failure.

### Testing results
- Valid files accepted
- Invalid MIME types rejected (422 response)
- Oversized files rejected (422 response)
- Missing file rejected (422 response)

---

## 4) Service Layer

**File:** `app/Services/DocumentService.php`

### Responsibilities
- Generate UUID-based filename
- Build date-structured path: `documents/YYYY/MM/`
- Store file using explicit disk: `Storage::disk('local')`
- Create database record with `status = UPLOADED`

### UUID naming rationale
- UUID chosen over hash-based naming to avoid dependency on file content
- Ensures uniqueness without read operation
- Prevents filename collisions in concurrent uploads

### Storage verification
- Physical path: `storage/app/documents/2026/02/`
- File naming: `be326786-0a08-454f-91e9-09ee8b956633.png`
- File confirmed on disk

---

## 5) API Layer

**File:** `app/Http/Controllers/Api/DocumentController.php`

### Clean architecture pattern
- Controller → Service → Model
- Minimal logic in controller
- Service handles business logic

### Endpoints implemented

#### POST /api/documents
Upload a new document

Request: `multipart/form-data` with `file` field  
Response (201):
```json
{
  "id": 1,
  "status": "UPLOADED",
  "original_filename": "facture.png",
  "mime_type": "image/png",
  "file_size": 6135,
  "created_at": "2026-02-12T16:04:18.000000Z"
}
```

Security note: `file_path` not exposed in API response for security reasons.

#### GET /api/documents
List all documents (paginated)

Response (200): Paginated collection with `data`, `links`, `meta`

#### GET /api/documents/{id}
Get single document

Response (200): Full document metadata including `status`, `doc_type`, `error_message`

---

### Routes

**File:** `routes/api.php`
```php
Route::prefix('documents')->group(function () {
    Route::post('/', [DocumentController::class, 'store']);
    Route::get('/', [DocumentController::class, 'index']);
    Route::get('/{document}', [DocumentController::class, 'show']);
});
```

All routes prefixed with `/api/` automatically by Laravel.

---

## 6) Testing Results (Postman)

### Test 1: Upload Document
- Method: POST
- URL: `http://127.0.0.1:8000/api/documents`
- Body: form-data, key=`file`, value=`facture.png`
- Result: 201 Created, document ID returned

### Test 2: Get Single Document
- Method: GET
- URL: `http://127.0.0.1:8000/api/documents/1`
- Result: 200 OK, full document metadata returned

### Test 3: List Documents
- Method: GET
- URL: `http://127.0.0.1:8000/api/documents`
- Result: 200 OK, paginated response with metadata

### Test 4: Physical File Storage
- Path: `C:\xampp\htdocs\pfe\backend\storage\app\documents\2026\02\`
- File: `be326786-0a08-454f-91e9-09ee8b956633.png`
- Result: File exists on disk

### Test 5: Database Record
- Table: `documents`
- Record: id=1, status=UPLOADED, file_path populated
- Result: Database record complete and accurate

---

## 7) Architecture Validation

### Day 2 Design Compliance
- Laravel owns file storage
- Laravel manages workflow states
- Status enum implementation
- Service layer separation
- RESTful API design
- Clean architecture principles

### SOLID Principles
- Single Responsibility (each class has one purpose)
- Dependency Injection (controller receives service)
- Open/Closed (service extensible without modification)

### Laravel Best Practices
- Route model binding enabled
- Explicit disk specification
- FormRequest validation
- Eloquent conventions
- Proper casts usage

---

## 8) System State at End of Day 3

### Current capabilities
- Secure file upload via API
- Metadata persistence in MySQL
- Structured filesystem storage (YYYY/MM/)
- UUID-based file naming
- Workflow state initialization (UPLOADED)
- Paginated document listing
- Single document retrieval
- Validation enforcement
- Clean service architecture

### Current workflow
```
UPLOADED (implemented)
    ↓
PROCESSING (planned Day 4)
    ↓
PROCESSED / FAILED (planned Day 4)
    ↓
VALIDATED (planned later)
```

---

## Out of scope (intentional for Day 3)

- Queue/Job implementation (Day 4)
- FastAPI integration (Day 4)
- OCR/AI processing (Day 4+)
- Authentication/Authorization
- CORS configuration
- Advanced error handling middleware
- Rate limiting



